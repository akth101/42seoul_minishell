# minishell  
유닉스 기반의 쉘 기능들을 구현하는 과제입니다.  
42서울의 대표적인 팀 과제로 저는 파싱된 입력을 실제로 실행시키는 부분과 시그널 처리를 맡았습니다.

---

### 목차
- [1. 구현 세부 사항](#1-구현-세부-사항)
- [2. 주요 기술적 이슈와 해결 과정](#2-주요-기술적-이슈와-해결-과정)
- [3. 평가 피드백](#3-평가-피드백)

---

### 1. 구현 세부 사항
- 새로운 명령어를 기다릴 때 프롬프트를 표시해야 합니다.  
- 작동하는 히스토리 기능이 있어야 합니다.  
- 실행 파일을 찾고 실행할 수 있어야 합니다 (PATH 변수를 기반으로 하거나 상대 또는 절대 경로 사용).  

#### 필수 기능:  
- 닫히지 않은 따옴표나 과제에서 요구하지 않는 특수 문자((백슬래시) 또는 ;(세미콜론) 등)는 해석하지 않습니다.  
- '(작은따옴표) 처리 - 따옴표로 묶인 시퀀스 내의 메타문자를 쉘이 해석하지 못하게 해야 합니다.  
- "(큰따옴표) 처리 - $(달러 기호)를 제외하고 따옴표로 묶인 시퀀스 내의 메타문자를 쉘이 해석하지 못하게 해야 합니다.  

#### 리다이렉션 구현:  
- `<` 입력 리다이렉션  
- `>` 출력 리다이렉션  
- `<<` 구분자가 주어지면, 구분자를 포함한 줄이 나올 때까지 입력을 읽습니다 (히스토리 업데이트는 불필요)  
- `>>` 구분자가 주어지면, append mode로 output을 리다이렉션해야 합니다.
 
#### 추가 기능:  
- 파이프(|) 구현 - 파이프라인의 각 명령어 출력이 파이프를 통해 다음 명령어의 입력으로 연결  
- 환경 변수 처리 ($ 다음에 문자 시퀀스) - 해당 값으로 확장되어야 함  
- $? 처리 - 가장 최근에 실행된 포그라운드 파이프라인의 종료 상태로 확장  

#### 시그널 처리:  
- ctrl-C, ctrl-D, ctrl-\ 는 bash처럼 동작해야 함  
- 대화형 모드에서:  
  - ctrl-C: 새 줄에 새로운 프롬프트 표시  
  - ctrl-D: 쉘 종료  

#### 내장 명령어 구현:  
- echo (-n 옵션 포함)  
- cd (상대 또는 절대 경로만)  
- pwd (옵션 없음)  
- export (옵션 없음)  
- unset (옵션 없음)  
- env (옵션이나 인자 없음)  
- exit (옵션 없음)  

---

### 2. 주요 기술적 이슈와 해결 과정  
#### 2-1) 논리 흐름의 분산으로 인한 스파게티 코드 해결하기   
처음에 이 과제를 시도할 때는 마땅한 설계 없이 바로 코드를 작성했습니다. 그러나 인자로 복합적인 명령어들이 들어올 때 수많은 경우의 수가 발생하였고 경우의 수가 하나씩 발견될 때마다 땜질식으로 코드를 추가하다 보니 제가 써 놓고도 무슨 코드인지 분간할 수 없는 지경에 이르렀습니다. 결국 처음에 썼던 코드는 모두 갈아엎을 수밖에 없었습니다. 

실행 흐름의 전개를 한눈에 보며 전체 그림을 그려야 할 필요성을 실감했고 이에 대한 해결책으로 플로우차트를 도입했습니다. 플로우차트를 작성하자 논리적 흐름을 한눈에 볼 수 있었고 수많은 경우의 수를 한눈에 조감할 수 있었습니다. 큰 프로그램의 실행 흐름을 한눈에 보며 문제가 발생할 만한 부분은 사전에 차단할 수 있었고 덕분에 아래와 같이 견고한 프로그램의 기초 로직을 세울 수 있었습니다.

<img width="1179" alt="스크린샷 2025-01-09 오후 7 36 15" src="https://github.com/user-attachments/assets/e0b170c3-55b0-4f35-a6ea-bd8015aae5ba" />

이 과정에서 설계의 중요성을 뼈저리게 깨달았습니다. 코드를 작성하기 전에 전체적인 흐름을 미리 그려보는 과정이 얼마나 중요한지, 그리고 이를 통해 복잡한 로직도 체계적으로 정리할 수 있다는 것을 배웠습니다. 특히 쉘이라는 복잡한 프로그램을 구현하면서 시스템 호출, 프로세스 관리, 파일 디스크립터 등 OS 레벨의 개념들을 실제로 다루며 더 깊은 이해를 얻을 수 있었습니다.

#### 2-2) 파이프 명령어 병렬 실행 불가로 인한 성능 병목 해결
"sleep 1 | sleep 1 | sleep 1" 명령어를 입력했을 때 각 명령어가 병렬로 1초 만에 실행되어야 했지만 3초가 걸렸습니다.  
O(1) 시간복잡도의 동작이 O(N) 시간복잡도로 수행되기 때문에 결코 넘어갈 수 없는 문제였습니다.  
따라서 ps 명령어로 "cat | cat | cat" 명령어의 동작을 테스트했는데 아래와 같은 현상이 나타났습니다.  

~~~ bash
[정상 기대값]
MacBookPro Desktop % ps
  PID TTY           TIME CMD
47476 ttys002    0:00.22 -zsh
49662 ttys005    0:00.18 -zsh
53202 ttys005    0:00.00 cat
53203 ttys005    0:00.00 cat
53204 ttys005    0:00.00 cat <------------------- 모든 cat 프로세스가 동시에 실행되어 입력을 기다리고 있는 정상적인 상태

[실제 결과값]
MacBookPro Desktop % ps
  PID TTY           TIME CMD
47476 ttys002    0:00.22 -zsh
49662 ttys005    0:00.18 -zsh
53202 ttys005    0:00.00 cat <------------------- 첫 번째 cat을 제외한 나머지 프로세스는 실행조차 되지 않음
~~~

위의 결과를 토대로 프로세스 생애주기 설계에 문제가 있을 것이라 예상했습니다.  
검토 결과 아래와 같이 자식 프로세스 생성과 wait 메서드 콜이 1:1 대응으로 설계되어 있다는 점을 발견했습니다.

 ~~~ c
while (++i < process.pipe_cnt + 1)
{
    // 프로세스 생성 로직...
    process.pid = fork();     //<------------- 자식 프로세스 생성
    if (process.pid == -1)
    {
        // 에러 처리...
    }
    else if (process.pid == 0)
        child_to_do(finder, &process, env);
    else
        parent_to_do(&process);  //<------------- 이 함수에서 wait 호출
}

~~~

위에서 발견한 설계 구조를 토대로 wait 메서드의 동작을 매뉴얼에서 확인했습니다:
~~~
The wait() function suspends execution of its calling process until
     stat_loc information is available for a terminated child process, or a
     signal is received.
~~~

즉, 자식이 종료될 때까지 부모 프로세스의 동작을 완전히 멈춰버리기 때문에 성능 병목이 발생할 수밖에 없는 상황이었고  
아래와 같이 모든 자식 프로세스를 먼저 생성한 후 마지막에 wait_child 메서드를 통해 wait을 호출하도록 설계를 변경해 문제를 해결했습니다:
~~~ c
while (++i < process.pipe_cnt + 1)
{
    // 파이프 및 프로세스 생성
    process.pid = fork();
    if (process.pid == 0)
        child_to_do(finder, &process, env);
    else
        parent_to_do(&process);  // <----------- wait 없는 버전
}
wait_child(process.pipe_cnt + 1);  // <------------ 모든 자식 프로세스 생성 후 대기


~~~

---

### 3. 평가 피드백  
<img width="1011" alt="스크린샷 2025-01-09 오후 7 14 48" src="https://github.com/user-attachments/assets/36200320-0755-4ccd-83b9-c81ebc6ba96d" />
